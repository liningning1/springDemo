<?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns="http://www.springframework.org/schema/security"
	xmlns:beans="http://www.springframework.org/schema/beans" 
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
	http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
	http://www.springframework.org/schema/security 
	http://www.springframework.org/schema/security/spring-security-3.1.xsd">
	
	<!-- 开发环境中可以配置<debug/>,会详细输出security的处理日志       正式的环境建议屏蔽<debug /> -->
	<http pattern="/login.jsp" security="none"/>
	<http pattern="/denied.jsp" security="none"/>
	<http pattern="/background/login.html" security="none"/>
	<http pattern="/background/loginCheck.html" security="none"/>
	
	<!-- 
	  开启支持方法注解的权限控制
	 @PreAuthorize:该注解用来确定该方法是否应该被执行 。该注解后面跟着的是一个表达式，若表达式为真，则方法执行。如@preAuthorize("hasRole('ROLE_USER')")表示只有该用户具有ROLE_USER权限此方法才会被执行
	 @PostAuthorize:该注解在方法执行之后进行访问控制检查。
	 @PostFilter:该注解用来对方法的返回结果进行过滤，从返回的集合中过滤掉表达式值为假的元素。如@PostFilter(hasPermission(filterObject,'read'))表示返回的结果只保留当前用户具有读权限的元素
	 @PreFilter:该注解用来对方法的参数值进行过滤。
	 将启动基于表达式的语法:
	 <global-method-security pre-post-annotations="enabled"/>
	 Spring Security中定义了四个支持使用表达式的注解，分别是@PreAuthorize、@PostAuthorize、@PreFilter和@PostFilter。
	   其中前两者可以用来在方法调用前或者调用后进行权限检查，后两者可以用来对集合类型的参数或者返回值进行过滤。
	   要使它们的定义能够对我们的方法的调用产生影响我们需要设置global-method-security元素的pre-post-annotations=”enabled”，默认为disabled。
	 -->
	
	<!-- 配置一个切入点entry-point-ref="authenticationProcessingFilterEntryPoint"，为了在未登陆的时候，跳转到哪个页面 -->
	<!-- use-expressions="true" 的意思是开启表达式      access-denied-page的意思是，当验证权限失败后会跳转到的页面-->
	<http use-expressions="true" auto-config="false" entry-point-ref="myAuthenticationEntryPoint" access-denied-page="/denied.jsp">
	   <!-- 以上未列出的,也都必须验证才能访问 -->
	   <intercept-url pattern="/background/**" access="isAuthenticated()"/>
	   <!-- 所有地址全开,无需验证 -->
	   <!--<intercept-url pattern="/**" access="permitAll"/>-->
	   <!-- 登出管理 
	    logout-success-url 属性:这个指定的URL会触发注销操作，默认是 /j_spring_security_logout
        invalidate-session 属性：如果为true，在注销的时候会销毁会话
        delete-cookies 属性：以逗号分隔的cookies名称，在用户注销时删除指定的cookies
	   -->
	   <logout logout-success-url="/j_spring_security_logout" logout-url="/background/login.html" invalidate-session="true" delete-cookies="JSESSIONID"/>
	   <!--在一定时间内实现免登陆验证-->
	   <remember-me/>
	   <!-- 会话管理
	   session超时跳转页面 以及每用户可拥有的session最大个数
	         如果每次退出后，必须要求用户必须重开浏览器才能登录，
	         可以将 invalid-session-url="/logout.jsp"，
	         防止有些 Web应用把用户的会话标识符直接通过 URL的参数来传递 
	    -->
	   <session-management invalid-session-url="/background/login.html" session-fixation-protection="none">
	       <concurrency-control max-sessions="1" error-if-maximum-exceeded="true"/>
	   </session-management>
	   <!-- 认证和授权 -->
	   <!-- 项目使用了自定义的登陆处理,如果使用security默认的,请将以下的注释去掉 -->
	   <!--<custom-filter ref="myLoginFilter" position="FORM_LOGIN_FILTER"/>-->
	   
	   <!--spring security 需要从数据库中获取用户,权限,资源来实现权限管理,需要自定义过滤器,
	          并且该过滤器必须在spring security 执行FILTER_SECURITY_INTERCEPTOR之前执行
	          因为该框架实现权限管理的实质就是在执行action之前先执行它框架中的为权限管理而设置的一系列的Filter        
	          我们自定义的这个SecurityFilter类要继承AbstractSecurityInterceptor接口和Filter类(负责传递一系列的Filter),
	          因为我们是从数据库总获取权限验证的数据,所以还要重写FilterInvocationSecuritymetadataSource接口,AccessDecisionManager接口,UserDetailsService接口,
	          只要重写了这3个接口,然后在spring配置文件中做相应的配置,项目启动后,在进行资源请求时,就自动会去执行我们的类进行权限控制。       
	   -->
	   <custom-filter ref="mySecurityFilter" position="FILTER_SECURITY_INTERCEPTOR"/> 
	</http>
	<!--
		<custom-filter ref="mySecurityFilter" before="FILTER_SECURITY_INTERCEPTOR"/>
		在http标签下配置一个我们自定义的继承了org.springframework.security.access.intercept.AbstractSecurityInterceptor的Filter，并注入其
		必须的3个组件authenticationManager、accessDecisionManager和securityMetadataSource。其作用上面已经注释了。
		这里的FILTER_SECURITY_INTERCEPTOR是Spring Security默认的Filter，
		我们自定义的Filter必须在它之前，过滤请求
	-->
	<!-- 未登录的切入点 -->
	<beans:bean id="myAuthenticationEntryPoint" class="org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint">
	    <beans:property name="loginFromUrl" value="/background/login.html"/>
	</beans:bean>
	<!-- 登录验证器,用户有没有登录的资格 init-method="init" 初始化方法
	项目使用了自定义登录处理，如果使用security的登录处理，请去掉以下注释-->
	<!-- <beans:bean id="myLoginFilter" init-method="init" class="com.lanyuan.security.MyAuthenticationFilter">
		<beans:property name="authenticationManager" ref="myAuthenticationManager" />
		<beans:property name="filterProcessesUrl" value="/background/j_security_check" />
		验证成功后要跳转的URL
		<beans:property name="successUrl" value="/background/index.html" />
		验证失败后要跳转的URL
		<beans:property name="errorUrl" value="/background/login.html" />
	</beans:bean> -->
	<!-- 认证管理器   实现了UserDetailsService的Bean 用户拥有的权限：登录后取得用户所保有的权限信息-->
	<authentication-manager alias="myAuthenticationManager">
	    <authentication-provider user-service-ref="myUserDetailServiceImpl"/>
	</authentication-manager>
</beans:beans>